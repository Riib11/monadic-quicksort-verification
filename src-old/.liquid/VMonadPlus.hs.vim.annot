1:1-1:1::$trModule :: "GHC.Types.Module"
58:1-58:12::raw_vaddMPF :: "forall a b c .\nx1:(a c -> a c -> a c) -> x4:(b -> a c) -> x6:(b -> a c) -> x8:b -> {VV : a c | VV == raw_vaddMPF x1 x4 x6 x8\n                                                                                && VV == x1 (x4 x8) (x6 x8)}"
58:13-58:18::<+> :: "a b -> a b -> a b"
58:19-58:20::f :: "a -> b c"
58:21-58:22::g :: "a -> b c"
58:23-58:24::x :: "a"
58:27-58:30::lq_anf$##7205759403792817849 :: "{v : a b | v == f x}"
58:29-58:30::x :: "{VV : a | VV == x}"
58:35-58:38::lq_anf$##7205759403792817850 :: "{v : a b | v == g x}"
58:37-58:38::x :: "{VV : a | VV == x}"
67:1-67:8::vaddMPF :: "forall a b c .\nx1:(VMonadPlus.VMonadPlus a) -> x2:(b -> a c) -> x4:(b -> a c) -> x6:b -> {VV : a c | VV == vaddMPF x1 x2 x4 x6\n                                                                                      && VV == raw_vaddMPF (vaddMP x1) x2 x4 x6}"
67:9-67:19::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
67:22-67:39::raw_vaddMPF :: "{VV : forall a b c .\n      x1:(a c -> a c -> a c) -> x4:(b -> a c) -> x6:(b -> a c) -> x8:b -> {v : a c | v == raw_vaddMPF x1 x4 x6 x8\n                                                                                     && v == x1 (x4 x8) (x6 x8)} | VV == raw_vaddMPF}"
67:34-67:39::<+> :: "a b -> a b -> a b"
69:5-69:10::<+> :: "a b -> a b -> a b"
69:13-69:30::_ :: "{VV : forall a . b a -> b a -> b a | VV == vaddMP iMonadPlus}"
69:20-69:30::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
74:1-74:6::guard :: "forall a .\nx1:(VMonadPlus.VMonadPlus a) -> x2:GHC.Types.Bool -> {VV : a () | VV == guard x1 x2\n                                                                  && VV == (if x2 then lift (iMonad x1) () else vepsilonMP x1)}"
74:7-74:17::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
74:18-74:19::b :: "GHC.Types.Bool"
74:22-74:57::lq_anf$##7205759403792817851 :: "{v : GHC.Types.Bool | v == b}"
74:25-74:26::_ :: "{v : GHC.Types.Bool | v == b}"
74:32-74:40::lift_ :: "() -> a ()"
74:38-74:40::() :: "{v : () | v == ()}"
74:46-74:57::vepsilonMP_ :: "{v : a () | v == vepsilonMP iMonadPlus\n            && v == vepsilonMP_}"
76:5-76:10::lift_ :: "() -> a ()"
76:13-76:25::_ :: "{VV : forall a . a -> b a | VV == lift iMonad_}"
76:18-76:25::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
77:5-77:16::vepsilonMP_ :: "{v : a () | v == vepsilonMP iMonadPlus}"
77:19-77:40::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus} | VV == vepsilonMP iMonadPlus}"
77:30-77:40::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
78:5-78:12::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
78:15-78:32::_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
78:22-78:32::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
83:1-83:8::guardBy :: "forall a b .\nx1:(VMonadPlus.VMonadPlus a) -> x2:(b -> GHC.Types.Bool) -> x4:b -> {VV : a b | VV == guardBy x1 x2 x4\n                                                                                && VV == vseq (iMonad x1) (guard x1 (x2 x4)) (lift (iMonad x1) x4)}"
83:9-83:19::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
83:20-83:21::p :: "a -> GHC.Types.Bool"
83:22-83:23::x :: "a"
83:26-83:38::lq_anf$##7205759403792817853 :: "a ()"
83:33-83:38::lq_anf$##7205759403792817852 :: "{v : GHC.Types.Bool | v == p x}"
83:36-83:37::x :: "{VV : a | VV == x}"
83:42-83:49::lq_anf$##7205759403792817854 :: "{v : a b | v == lift_ x}"
83:48-83:49::x :: "{VV : a | VV == x}"
85:5-85:9::>> :: "x1:a () -> x2:a b -> {v : a b | v == vseq iMonad_ x1 x2\n                                && v == bind iMonad_ x1 (vconst x2)}"
85:12-85:24::_ :: "x1:a () -> x2:a b -> {v : a b | v == vseq iMonad_ x1 x2\n                                && v == bind iMonad_ x1 (vconst x2)}"
85:17-85:24::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
86:5-86:11::guard_ :: "x1:GHC.Types.Bool -> {v : a () | v == guard iMonadPlus x1\n                                 && v == (if x1 then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)}"
86:14-86:30::_ :: "x1:GHC.Types.Bool -> {v : a () | v == guard iMonadPlus x1\n                                 && v == (if x1 then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)}"
86:20-86:30::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
87:5-87:10::lift_ :: "a -> b a"
87:13-87:25::_ :: "{VV : forall a . a -> b a | VV == lift iMonad_}"
87:18-87:25::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
88:5-88:12::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
88:15-88:32::_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
88:22-88:32::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
108:1-108:19::vepsilonMP_refines :: "forall a b .\nx1:(VMonadPlus.VMonadPlus a) -> x2:a b -> {VV : () | vaddMP x1 (vepsilonMP x1) x2 == x2}"
108:20-108:30::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
108:31-108:32::x :: "a b"
108:35-108:53::vaddMP_identity_ :: "x1:a b -> {v : () | vaddMP iMonadPlus (vepsilonMP iMonadPlus) x1 == x1\n                    && vaddMP iMonadPlus x1 (vepsilonMP iMonadPlus) == x1}"
108:52-108:53::x :: "{v : a b | v == x}"
110:5-110:21::vaddMP_identity_ :: "x:a b -> {v : () | vaddMP iMonadPlus (vepsilonMP iMonadPlus) x == x\n                   && vaddMP iMonadPlus x (vepsilonMP iMonadPlus) == x}"
110:24-110:50::_ :: "{VV : forall a .\n      x:b a -> {v : () | vaddMP iMonadPlus (vepsilonMP iMonadPlus) x == x\n                         && vaddMP iMonadPlus x (vepsilonMP iMonadPlus) == x} | VV == vaddMP_identity iMonadPlus}"
110:40-110:50::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
119:1-119:17::identity_refines :: "forall a b .\nx1:(VMonadPlus.VMonadPlus b) -> x2:b b -> {VV : () | vaddMP x1 x2 x2 == x2}"
132:1-132:23::component_left_refines :: "forall a b .\nx1:(VMonadPlus.VMonadPlus b) -> x2:b b -> x3:b b -> {VV : () | vaddMP x1 x2 (vaddMP x1 x2 x3) == vaddMP x1 x2 x3}"
145:1-145:24::component_right_refines :: "forall a b .\nx1:(VMonadPlus.VMonadPlus b) -> x2:b b -> x3:b b -> {VV : () | vaddMP x1 x3 (vaddMP x1 x2 x3) == vaddMP x1 x2 x3}"
163:1-163:26::bind_monotonic_refinement :: "forall a b c .\nx1:(VMonadPlus.VMonadPlus a) -> x2:a b -> x3:a b -> x4:(b -> a c) -> {H : () | vaddMP x1 x2 x3 == x3} -> {VV : () | vaddMP x1 (bind (iMonad x1) x2 x4) (bind (iMonad x1) x3 x4) == bind (iMonad x1) x3 x4}"
163:27-163:37::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
163:38-163:39::x :: "a b"
163:40-163:41::y :: "a b"
163:42-163:43::f :: "a -> b c"
163:44-163:51::ref_x_y :: "{H : () | vaddMP iMonadPlus x y == y}"
164:3-164:12::lq_anf$##7205759403792817863 :: "{v : a b | v == >>= x f}"
164:4-164:5::x :: "{v : a b | v == x}"
164:10-164:11::f :: "a -> b c"
164:17-164:26::lq_anf$##7205759403792817864 :: "{v : a b | v == >>= y f}"
164:18-164:19::y :: "{v : a b | v == y}"
164:24-164:25::f :: "a -> b c"
165:9-165:60::lq_anf$##7205759403792817869 :: "{v : a b<pa> | true}"
165:10-165:19::lq_anf$##7205759403792817866 :: "{v : a b | v == <+> x y}"
165:11-165:12::x :: "{v : a b | v == x}"
165:17-165:18::y :: "{v : a b | v == y}"
165:24-165:25::f :: "a -> b c"
165:28-165:59::lq_anf$##7205759403792817868 :: "{v : () | bind (iMonad iMonadPlus) (vaddMP iMonadPlus x y) f == vaddMP iMonadPlus (bind (iMonad iMonadPlus) x f) (bind (iMonad iMonadPlus) y f)\n          && v == vaddMP_distributive_left_ x y f}"
165:54-165:55::x :: "{v : a b | v == x}"
165:56-165:57::y :: "{v : a b | v == y}"
165:58-165:59::f :: "a -> b c"
166:9-166:28::lq_anf$##7205759403792817872 :: "{v : a b<pa> | true}"
166:10-166:11::y :: "{v : a b | v == y}"
166:16-166:17::f :: "a -> b c"
166:20-166:27::ref_x_y :: "{v : () | vaddMP iMonadPlus x y == y\n          && v == ref_x_y}"
167:9-167:12::QED :: "{v : Language.Haskell.Liquid.Equational.QED | v == QED}"
169:5-169:10::>>= :: "a b -> (b -> a c) -> a c"
169:13-169:25::_ :: "{VV : forall a b . c a -> (a -> c b) -> c b | VV == bind iMonad_}"
169:18-169:25::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
171:5-171:10::<+> :: "forall a . b a -> b a -> b a"
171:13-171:30::_ :: "{VV : forall a . b a -> b a -> b a | VV == vaddMP iMonadPlus}"
171:20-171:30::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
172:5-172:12::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
172:15-172:32::_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
172:22-172:32::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
174:5-174:30::vaddMP_distributive_left_ :: "x:a b -> y:a b -> f:(b -> a c) -> {v : () | bind (iMonad iMonadPlus) (vaddMP iMonadPlus x y) f == vaddMP iMonadPlus (bind (iMonad iMonadPlus) x f) (bind (iMonad iMonadPlus) y f)}"
174:33-174:68::_ :: "{VV : forall a b .\n      x:c a -> y:c a -> f:(a -> c b) -> {v : () | bind (iMonad iMonadPlus) (vaddMP iMonadPlus x y) f == vaddMP iMonadPlus (bind (iMonad iMonadPlus) x f) (bind (iMonad iMonadPlus) y f)} | VV == vaddMP_distributive_left iMonadPlus}"
174:58-174:68::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
189:1-189:27::guard_isCommutativeMonadic :: "forall a b c .\nx1:(VMonadPlus.VMonadPlus a) -> x2:GHC.Types.Bool -> x3:a b -> x4:(b -> c) -> {VV : () | vmapM2 (iMonad x1) (vconstF x4) (guard x1 x2) x3 == vmapM2 (iMonad x1) (vflip (vconstF x4)) x3 (guard x1 x2)}"
189:28-189:38::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
189:44-189:45::x :: "a b"
189:46-189:47::f :: "a -> b"
190:3-190:38::lq_anf$##7205759403792817946 :: "a b"
190:11-190:22::lq_anf$##7205759403792817944 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
190:20-190:21::f :: "a -> b"
190:23-190:36::lq_anf$##7205759403792817945 :: "{v : a () | v == guard iMonadPlus True\n            && v == (if True then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)\n            && v == guard_ True}"
190:31-190:35::True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
190:37-190:38::x :: "{v : a b | v == x}"
192:9-192:20::lq_anf$##7205759403792817947 :: "{v : a () | v == guard iMonadPlus True\n            && v == (if True then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)\n            && v == guard_ True}"
192:16-192:20::True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
192:25-192:51::lq_anf$##7205759403792817949 :: "() -> a b"
192:38-192:49::lq_anf$##7205759403792817948 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
192:47-192:48::f :: "a -> b"
192:50-192:51::x :: "{v : a b | v == x}"
194:9-194:17::lq_anf$##7205759403792817952 :: "{v : a () | v == lift_ ()}"
194:15-194:17::() :: "{v : () | v == ()}"
194:22-194:48::lq_anf$##7205759403792817954 :: "() -> a b"
194:35-194:46::lq_anf$##7205759403792817953 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
194:44-194:45::f :: "a -> b"
194:47-194:48::x :: "{v : a b | v == x}"
196:11-196:40::lq_anf$##7205759403792817958 :: "a b"
196:24-196:35::lq_anf$##7205759403792817957 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
196:33-196:34::f :: "a -> b"
196:36-196:37::x :: "{v : a b | v == x}"
196:38-196:40::() :: "{v : () | v == ()}"
197:15-197:59::lq_anf$##7205759403792817961 :: "()"
197:26-197:54::lq_anf$##7205759403792817960 :: "() -> a b"
197:40-197:51::lq_anf$##7205759403792817959 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
197:49-197:50::f :: "a -> b"
197:52-197:53::x :: "{v : a b | v == x}"
197:55-197:59::() :: "{v : () | v == ()}"
200:9-200:10::x :: "{v : a b | v == x}"
200:15-200:42::lq_anf$##7205759403792817965 :: "a -> b c"
200:28-200:39::lq_anf$##7205759403792817964 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
200:37-200:38::f :: "a -> b"
200:40-200:42::() :: "{v : () | v == ()}"
203:11-203:12::x :: "{v : a b | v == x}"
203:17-203:60::lq_anf$##7205759403792817971 :: "a -> b c"
203:30-203:49::lq_anf$##7205759403792817969 :: "a -> () -> b"
203:37-203:48::lq_anf$##7205759403792817968 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
203:46-203:47::f :: "a -> b"
203:50-203:60::lq_anf$##7205759403792817970 :: "{v : a () | v == lift_ ()}"
203:57-203:59::() :: "{v : () | v == ()}"
205:19-205:48::lq_anf$##7205759403792817974 :: "a -> b c"
205:33-205:44::lq_anf$##7205759403792817973 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
205:42-205:43::f :: "a -> b"
205:45-205:47::() :: "{v : () | v == ()}"
206:19-206:64::lq_anf$##7205759403792817978 :: "a -> b c"
206:33-206:52::lq_anf$##7205759403792817976 :: "a -> () -> b"
206:40-206:51::lq_anf$##7205759403792817975 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
206:49-206:50::f :: "a -> b"
206:53-206:63::lq_anf$##7205759403792817977 :: "{v : a () | v == lift_ ()}"
206:60-206:62::() :: "{v : () | v == ()}"
207:19-207:60::lq_anf$##7205759403792817979 :: "x1:a -> {v : () | vmapM2_aux2 iMonad_ (vconstF f) () x1 == vmapM2_aux1 iMonad_ (vflip (vconstF f)) (lift iMonad_ ()) x1}"
207:58-207:59::f :: "a -> b"
211:9-211:10::x :: "{v : a b | v == x}"
211:15-211:61::lq_anf$##7205759403792817986 :: "a -> b c"
211:28-211:47::lq_anf$##7205759403792817984 :: "a -> () -> b"
211:35-211:46::lq_anf$##7205759403792817983 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
211:44-211:45::f :: "a -> b"
211:48-211:61::lq_anf$##7205759403792817985 :: "{v : a () | v == guard iMonadPlus True\n            && v == (if True then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)\n            && v == guard_ True}"
211:56-211:60::True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
213:9-213:52::lq_anf$##7205759403792817992 :: "a b"
213:17-213:36::lq_anf$##7205759403792817990 :: "a -> () -> b"
213:24-213:35::lq_anf$##7205759403792817989 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
213:33-213:34::f :: "a -> b"
213:37-213:38::x :: "{v : a b | v == x}"
213:39-213:52::lq_anf$##7205759403792817991 :: "{v : a () | v == guard iMonadPlus True\n            && v == (if True then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)\n            && v == guard_ True}"
213:47-213:51::True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
214:9-214:12::QED :: "{v : Language.Haskell.Liquid.Equational.QED | v == QED}"
219:5-219:10::>>= :: "forall a b . c a -> (a -> c b) -> c b"
219:13-219:25::_ :: "{VV : forall a b . c a -> (a -> c b) -> c b | VV == bind iMonad_}"
219:18-219:25::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
220:5-220:10::lift_ :: "() -> a ()"
220:13-220:25::_ :: "{VV : forall a . a -> b a | VV == lift iMonad_}"
220:18-220:25::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
222:5-222:12::vmapM2_ :: "forall a b c .\nx1:(a -> b -> c) -> x4:d a -> x5:d b -> {v : d c | v == vmapM2 iMonad_ x1 x4 x5\n                                                   && v == bind iMonad_ x4 (vmapM2_aux1 iMonad_ x1 x5)}"
222:15-222:29::_ :: "x1:(a -> b -> c) -> x4:d a -> x5:d b -> {v : d c | v == vmapM2 iMonad_ x1 x4 x5\n                                                   && v == bind iMonad_ x4 (vmapM2_aux1 iMonad_ x1 x5)}"
222:22-222:29::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
224:5-224:17::vmapM2_aux1_ :: "forall a b c .\nx1:(a -> b -> c) -> x4:d b -> x5:a -> {v : d c | v == vmapM2_aux1 iMonad_ x1 x4 x5\n                                                 && v == bind iMonad_ x4 (vmapM2_aux2 iMonad_ x1 x5)}"
224:20-224:39::_ :: "x1:(a -> b -> c) -> x4:d b -> x5:a -> {v : d c | v == vmapM2_aux1 iMonad_ x1 x4 x5\n                                                 && v == bind iMonad_ x4 (vmapM2_aux2 iMonad_ x1 x5)}"
224:32-224:39::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
226:5-226:17::vmapM2_aux2_ :: "forall a b c .\nx1:(a -> b -> c) -> x4:a -> x5:b -> {v : d c | v == vmapM2_aux2 iMonad_ x1 x4 x5\n                                               && v == lift iMonad_ (x1 x4 x5)}"
226:20-226:39::_ :: "x1:(a -> b -> c) -> x4:a -> x5:b -> {v : d c | v == vmapM2_aux2 iMonad_ x1 x4 x5\n                                               && v == lift iMonad_ (x1 x4 x5)}"
226:32-226:39::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
227:5-227:15::bind_lift_ :: "k:(() -> a b) -> x:() -> {v : () | bind iMonad_ (lift iMonad_ x) k == k x}"
227:18-227:35::_ :: "{VV : forall a b .\n      k:(a -> c b) -> x:a -> {v : () | bind iMonad_ (lift iMonad_ x) k == k x} | VV == bind_lift iMonad_}"
227:28-227:35::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
228:5-228:42::guard_isCommutativeMonadic_True_lem1_ :: "x1:(a -> b) -> x3:a -> {v : () | vmapM2_aux2 iMonad_ (vconstF x1) () x3 == vmapM2_aux1 iMonad_ (vflip (vconstF x1)) (lift iMonad_ ()) x3}"
230:9-230:16::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
231:5-231:12::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
231:15-231:32::_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
231:22-231:32::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
233:5-233:11::guard_ :: "x1:GHC.Types.Bool -> {v : a () | v == guard iMonadPlus x1\n                                 && v == (if x1 then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)}"
233:14-233:30::_ :: "x1:GHC.Types.Bool -> {v : a () | v == guard iMonadPlus x1\n                                 && v == (if x1 then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)}"
233:20-233:30::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
236:3-236:39::lq_anf$##7205759403792817900 :: "a b"
236:11-236:22::lq_anf$##7205759403792817898 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
236:20-236:21::f :: "a -> b"
236:23-236:37::lq_anf$##7205759403792817899 :: "{v : a () | v == guard iMonadPlus False\n            && v == (if False then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)\n            && v == guard_ False}"
236:31-236:36::False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
236:38-236:39::x :: "{v : a b | v == x}"
238:9-238:42::lq_anf$##7205759403792817903 :: "a b"
238:17-238:28::lq_anf$##7205759403792817901 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
238:26-238:27::f :: "a -> b"
238:29-238:40::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus\n                 && v == vepsilonMP_} | VV == vepsilonMP iMonadPlus\n                                        && VV == vepsilonMP_}"
238:41-238:42::x :: "{v : a b | v == x}"
240:9-240:20::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus\n                 && v == vepsilonMP_} | VV == vepsilonMP iMonadPlus\n                                        && VV == vepsilonMP_}"
240:25-240:51::lq_anf$##7205759403792817907 :: "a -> b c"
240:38-240:49::lq_anf$##7205759403792817906 :: "x1:a -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                          && VV == f x2}"
240:47-240:48::f :: "a -> b"
240:50-240:51::x :: "{v : a b | v == x}"
242:11-242:22::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus\n                 && v == vepsilonMP_} | VV == vepsilonMP iMonadPlus\n                                        && VV == vepsilonMP_}"
243:15-243:59::lq_anf$##7205759403792817913 :: "()"
243:31-243:59::lq_anf$##7205759403792817912 :: "a -> b c"
243:45-243:56::lq_anf$##7205759403792817911 :: "x1:a -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                          && VV == f x2}"
243:54-243:55::f :: "a -> b"
243:57-243:58::x :: "{v : a b | v == x}"
246:11-246:12::x :: "{v : a b | v == x}"
246:16-246:27::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus\n                 && v == vepsilonMP_} | VV == vepsilonMP iMonadPlus\n                                        && VV == vepsilonMP_}"
247:15-247:33::lq_anf$##7205759403792817918 :: "{v : () | vseq (iMonad iMonadPlus) x (vepsilonMP iMonadPlus) == vepsilonMP iMonadPlus\n          && v == vseq_zero_right_ x}"
247:32-247:33::x :: "{v : a b | v == x}"
250:9-250:10::x :: "{v : a b | v == x}"
250:15-250:33::lq_anf$##7205759403792817922 :: "a -> b c"
250:22-250:33::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus\n                 && v == vepsilonMP_} | VV == vepsilonMP iMonadPlus\n                                        && VV == vepsilonMP_}"
252:11-252:12::x :: "{v : a b | v == x}"
252:17-252:61::lq_anf$##7205759403792817928 :: "a -> b c"
252:30-252:49::lq_anf$##7205759403792817926 :: "a -> a -> b"
252:37-252:48::lq_anf$##7205759403792817925 :: "x1:a -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                          && VV == f x2}"
252:46-252:47::f :: "a -> b"
252:50-252:61::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus\n                 && v == vepsilonMP_} | VV == vepsilonMP iMonadPlus\n                                        && VV == vepsilonMP_}"
253:15-253:55::lq_anf$##7205759403792817930 :: "x1:a -> {v : () | vconst (vepsilonMP iMonadPlus) x1 == vmapM2_aux1 (iMonad iMonadPlus) (vflip (vconstF f)) (vepsilonMP iMonadPlus) x1}"
253:54-253:55::f :: "a -> b"
256:9-256:10::x :: "{v : a b | v == x}"
256:15-256:69::lq_anf$##7205759403792817936 :: "a -> b c"
256:27-256:34::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
256:35-256:54::lq_anf$##7205759403792817934 :: "a -> () -> b"
256:42-256:53::lq_anf$##7205759403792817933 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
256:51-256:52::f :: "a -> b"
256:55-256:69::lq_anf$##7205759403792817935 :: "{v : a () | v == guard iMonadPlus False\n            && v == (if False then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)\n            && v == guard_ False}"
256:63-256:68::False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
258:9-258:60::lq_anf$##7205759403792817942 :: "a b"
258:16-258:23::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
258:24-258:43::lq_anf$##7205759403792817940 :: "a -> () -> b"
258:31-258:42::lq_anf$##7205759403792817939 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
258:40-258:41::f :: "a -> b"
258:44-258:45::x :: "{v : a b | v == x}"
258:46-258:60::lq_anf$##7205759403792817941 :: "{v : a () | v == guard iMonadPlus False\n            && v == (if False then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)\n            && v == guard_ False}"
258:54-258:59::False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
259:9-259:12::QED :: "{v : Language.Haskell.Liquid.Equational.QED | v == QED}"
262:5-262:9::>> :: "x1:a b -> x2:a c -> {v : a c | v == vseq iMonad_ x1 x2\n                               && v == bind iMonad_ x1 (vconst x2)}"
262:12-262:24::_ :: "x1:a b -> x2:a c -> {v : a c | v == vseq iMonad_ x1 x2\n                               && v == bind iMonad_ x1 (vconst x2)}"
262:17-262:24::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
263:5-263:10::>>= :: "a b -> (b -> a c) -> a c"
263:13-263:25::_ :: "{VV : forall a b . c a -> (a -> c b) -> c b | VV == bind iMonad_}"
263:18-263:25::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
265:5-265:12::vmapM2_ :: "x1:(() -> a -> b) -> x4:c () -> x5:c a -> {v : c b | v == vmapM2 iMonad_ x1 x4 x5\n                                                     && v == bind iMonad_ x4 (vmapM2_aux1 iMonad_ x1 x5)}"
265:15-265:29::_ :: "x1:(() -> a -> b) -> x4:c () -> x5:c a -> {v : c b | v == vmapM2 iMonad_ x1 x4 x5\n                                                     && v == bind iMonad_ x4 (vmapM2_aux1 iMonad_ x1 x5)}"
265:22-265:29::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
266:5-266:17::vmapM2_aux1_ :: "x1:(a -> a -> b) -> x4:c a -> x5:a -> {v : c b | v == vmapM2_aux1 iMonad_ x1 x4 x5\n                                                 && v == bind iMonad_ x4 (vmapM2_aux2 iMonad_ x1 x5)}"
266:20-266:39::_ :: "x1:(a -> a -> b) -> x4:c a -> x5:a -> {v : c b | v == vmapM2_aux1 iMonad_ x1 x4 x5\n                                                 && v == bind iMonad_ x4 (vmapM2_aux2 iMonad_ x1 x5)}"
266:32-266:39::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
272:5-272:12::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
272:15-272:32::_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
272:22-272:32::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
274:5-274:11::guard_ :: "x1:GHC.Types.Bool -> {v : a () | v == guard iMonadPlus x1\n                                 && v == (if x1 then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)}"
274:14-274:30::_ :: "x1:GHC.Types.Bool -> {v : a () | v == guard iMonadPlus x1\n                                 && v == (if x1 then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)}"
274:20-274:30::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
275:5-275:20::bind_zero_left_ :: "f:(a -> b c) -> {v : () | bind (iMonad iMonadPlus) (vepsilonMP iMonadPlus) f == vepsilonMP iMonadPlus}"
275:23-275:48::_ :: "{VV : forall a b .\n      f:(a -> c b) -> {v : () | bind (iMonad iMonadPlus) (vepsilonMP iMonadPlus) f == vepsilonMP iMonadPlus} | VV == bind_zero_left iMonadPlus}"
275:38-275:48::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
277:5-277:16::vepsilonMP_ :: "forall a . {v : b a | v == vepsilonMP iMonadPlus}"
277:19-277:40::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus} | VV == vepsilonMP iMonadPlus}"
277:30-277:40::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
278:5-278:21::vseq_zero_right_ :: "x:a b -> {v : () | vseq (iMonad iMonadPlus) x (vepsilonMP iMonadPlus) == vepsilonMP iMonadPlus}"
278:24-278:50::_ :: "{VV : forall a .\n      x:b a -> {v : () | vseq (iMonad iMonadPlus) x (vepsilonMP iMonadPlus) == vepsilonMP iMonadPlus} | VV == vseq_zero_right iMonadPlus}"
278:40-278:50::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
279:5-279:43::guard_isCommutativeMonadic_False_lem1_ :: "x1:(a -> b) -> x3:a -> {v : () | vconst (vepsilonMP iMonadPlus) x3 == vmapM2_aux1 (iMonad iMonadPlus) (vflip (vconstF x1)) (vepsilonMP iMonadPlus) x3}"
281:9-281:19::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
295:1-295:37::guard_isCommutativeMonadic_True_lem1 :: "forall a b c .\nx1:(VMonad.VMonad a) -> x2:(b -> c) -> x4:b -> {VV : () | vmapM2_aux2 x1 (vconstF x2) () x4 == vmapM2_aux1 x1 (vflip (vconstF x2)) (lift x1 ()) x4}"
295:38-295:45::iMonad_ :: "(VMonad.VMonad a)"
295:46-295:47::f :: "a -> b"
295:48-295:49::x :: "a"
296:3-296:30::lq_anf$##7205759403792817875 :: "a -> b c"
296:16-296:27::lq_anf$##7205759403792817874 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
296:25-296:26::f :: "a -> b"
296:28-296:30::() :: "{v : () | v == ()}"
297:9-297:52::lq_anf$##7205759403792817879 :: "a -> b c"
297:22-297:41::lq_anf$##7205759403792817877 :: "a -> () -> b"
297:29-297:40::lq_anf$##7205759403792817876 :: "x1:() -> x2:a -> {VV : b | VV == vconstF f x1 x2\n                           && VV == f x2}"
297:38-297:39::f :: "a -> b"
297:42-297:52::lq_anf$##7205759403792817878 :: "{v : a () | v == lift_ ()}"
297:49-297:51::() :: "{v : () | v == ()}"
298:9-298:12::QED :: "{v : Language.Haskell.Liquid.Equational.QED | v == QED}"
300:5-300:10::lift_ :: "() -> a ()"
300:13-300:25::_ :: "{VV : forall a . a -> b a | VV == lift iMonad_}"
300:18-300:25::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad_}"
301:5-301:17::vmapM2_aux2_ :: "x1:(() -> a -> b) -> x4:() -> x5:a -> {v : c b | v == vmapM2_aux2 iMonad_ x1 x4 x5\n                                                 && v == lift iMonad_ (x1 x4 x5)}"
301:20-301:39::_ :: "x1:(() -> a -> b) -> x4:() -> x5:a -> {v : c b | v == vmapM2_aux2 iMonad_ x1 x4 x5\n                                                 && v == lift iMonad_ (x1 x4 x5)}"
301:32-301:39::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad_}"
302:5-302:17::vmapM2_aux1_ :: "x1:(a -> () -> b) -> x4:c () -> x5:a -> {v : c b | v == vmapM2_aux1 iMonad_ x1 x4 x5\n                                                   && v == bind iMonad_ x4 (vmapM2_aux2 iMonad_ x1 x5)}"
302:20-302:39::_ :: "x1:(a -> () -> b) -> x4:c () -> x5:a -> {v : c b | v == vmapM2_aux1 iMonad_ x1 x4 x5\n                                                   && v == bind iMonad_ x4 (vmapM2_aux2 iMonad_ x1 x5)}"
302:32-302:39::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad_}"
317:1-317:38::guard_isCommutativeMonadic_False_lem1 :: "forall a b c .\nx1:(VMonadPlus.VMonadPlus a) -> x2:(b -> c) -> x4:b -> {VV : () | vconst (vepsilonMP x1) x4 == vmapM2_aux1 (iMonad x1) (vflip (vconstF x2)) (vepsilonMP x1) x4}"
317:39-317:49::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
317:50-317:51::f :: "a -> b"
317:52-317:53::x :: "a"
318:3-318:23::lq_anf$##7205759403792817881 :: "{v : a b | v == vconst vepsilonMP_ x\n           && v == vepsilonMP_}"
318:10-318:21::vepsilonMP_ :: "{v : a b | v == vepsilonMP iMonadPlus\n           && v == vepsilonMP_}"
318:22-318:23::x :: "{VV : a | VV == x}"
319:9-319:20::vepsilonMP_ :: "{v : a b | v == vepsilonMP iMonadPlus\n           && v == vepsilonMP_}"
321:11-321:22::vepsilonMP_ :: "{v : a b | v == vepsilonMP iMonadPlus\n           && v == vepsilonMP_}"
321:27-321:61::lq_anf$##7205759403792817885 :: "a -> b a"
321:40-321:59::lq_anf$##7205759403792817884 :: "a -> b -> b"
321:47-321:58::lq_anf$##7205759403792817883 :: "x1:a -> x2:b -> {VV : a | VV == vconstF f x1 x2\n                          && VV == f x2}"
321:56-321:57::f :: "a -> b"
321:60-321:61::x :: "{VV : a | VV == x}"
322:15-322:67::lq_anf$##7205759403792817890 :: "()"
322:31-322:67::lq_anf$##7205759403792817889 :: "a -> b a"
322:45-322:64::lq_anf$##7205759403792817888 :: "a -> b -> b"
322:52-322:63::lq_anf$##7205759403792817887 :: "x1:a -> x2:b -> {VV : a | VV == vconstF f x1 x2\n                          && VV == f x2}"
322:61-322:62::f :: "a -> b"
322:65-322:66::x :: "{VV : a | VV == x}"
325:9-325:55::lq_anf$##7205759403792817895 :: "a b"
325:22-325:41::lq_anf$##7205759403792817894 :: "a -> b -> b"
325:29-325:40::lq_anf$##7205759403792817893 :: "x1:a -> x2:b -> {VV : a | VV == vconstF f x1 x2\n                          && VV == f x2}"
325:38-325:39::f :: "a -> b"
325:42-325:53::vepsilonMP_ :: "{v : a b | v == vepsilonMP iMonadPlus\n           && v == vepsilonMP_}"
325:54-325:55::x :: "{VV : a | VV == x}"
326:9-326:12::QED :: "{v : Language.Haskell.Liquid.Equational.QED | v == QED}"
328:5-328:10::>>= :: "a b -> (b -> a b) -> a b"
328:13-328:25::_ :: "{VV : forall a b . c a -> (a -> c b) -> c b | VV == bind iMonad_}"
328:18-328:25::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
329:5-329:17::vmapM2_aux1_ :: "x1:(a -> b -> b) -> x4:c b -> x5:a -> {v : c b | v == vmapM2_aux1 iMonad_ x1 x4 x5\n                                                 && v == bind iMonad_ x4 (vmapM2_aux2 iMonad_ x1 x5)}"
329:20-329:39::_ :: "x1:(a -> b -> b) -> x4:c b -> x5:a -> {v : c b | v == vmapM2_aux1 iMonad_ x1 x4 x5\n                                                 && v == bind iMonad_ x4 (vmapM2_aux2 iMonad_ x1 x5)}"
329:32-329:39::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
330:5-330:17::vmapM2_aux2_ :: "x1:(a -> b -> b) -> x4:a -> x5:b -> {v : c b | v == vmapM2_aux2 iMonad_ x1 x4 x5\n                                               && v == lift iMonad_ (x1 x4 x5)}"
330:20-330:39::_ :: "x1:(a -> b -> b) -> x4:a -> x5:b -> {v : c b | v == vmapM2_aux2 iMonad_ x1 x4 x5\n                                               && v == lift iMonad_ (x1 x4 x5)}"
330:32-330:39::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus\n                         && v == iMonad_}"
331:5-331:12::iMonad_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
331:15-331:32::_ :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
331:22-331:32::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
332:5-332:16::vepsilonMP_ :: "{v : a b | v == vepsilonMP iMonadPlus}"
332:19-332:40::_ :: "{VV : forall a .\n      {v : b a | v == vepsilonMP iMonadPlus} | VV == vepsilonMP iMonadPlus}"
332:30-332:40::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
333:5-333:20::bind_zero_left_ :: "f:(a -> b a) -> {v : () | bind (iMonad iMonadPlus) (vepsilonMP iMonadPlus) f == vepsilonMP iMonadPlus}"
333:23-333:48::_ :: "{VV : forall a b .\n      f:(a -> c b) -> {v : () | bind (iMonad iMonadPlus) (vepsilonMP iMonadPlus) f == vepsilonMP iMonadPlus} | VV == bind_zero_left iMonadPlus}"
333:38-333:48::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
338:1-338:10::guard_and :: "forall a .\nx1:(VMonadPlus.VMonadPlus a) -> x2:GHC.Types.Bool -> x3:GHC.Types.Bool -> {VV : a () | VV == guard_and x1 x2 x3\n                                                                                       && VV == guard x1 (vand x2 x3)}"
338:11-338:21::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
338:22-338:24::b1 :: "GHC.Types.Bool"
338:25-338:27::b2 :: "GHC.Types.Bool"
338:36-338:46::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
338:47-338:59::lq_anf$##7205759403792817855 :: "{v : GHC.Types.Bool | v == vand b1 b2\n                      && v == (if b1 then b2 else false)}"
338:53-338:55::b1 :: "{v : GHC.Types.Bool | v == b1}"
338:56-338:58::b2 :: "{v : GHC.Types.Bool | v == b2}"
350:1-350:15::guard_and_vseq :: "forall a .\nx1:(VMonadPlus.VMonadPlus a) -> x2:GHC.Types.Bool -> x3:GHC.Types.Bool -> {VV : () | guard_and x1 x2 x3 == vseq (iMonad x1) (guard x1 x2) (guard x1 x3)}"
356:1-356:15::guard_disjoint :: "forall a b .\nx1:(VMonadPlus.VMonadPlus a) -> x2:GHC.Types.Bool -> x3:a b -> x4:a b -> {VV : a b | VV == guard_disjoint x1 x2 x3 x4\n                                                                                     && VV == vaddMP x1 (vseq (iMonad x1) (guard x1 x2) x3) (vseq (iMonad x1) (guard x1 (vnot x2)) x4)}"
356:16-356:26::iMonadPlus :: "(VMonadPlus.VMonadPlus a)"
356:27-356:28::b :: "GHC.Types.Bool"
356:29-356:30::x :: "a b"
356:31-356:32::y :: "a b"
358:5-358:15::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
359:5-359:54::lq_anf$##7205759403792817858 :: "a b"
359:11-359:30::lq_anf$##7205759403792817856 :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
359:19-359:29::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
359:31-359:51::lq_anf$##7205759403792817857 :: "{v : a () | v == guard iMonadPlus b\n            && v == (if b then lift (iMonad iMonadPlus) () else vepsilonMP iMonadPlus)}"
359:38-359:48::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
359:49-359:50::b :: "{v : GHC.Types.Bool | v == b}"
359:52-359:53::x :: "{v : a b | v == x}"
360:5-360:61::lq_anf$##7205759403792817862 :: "a b"
360:11-360:30::lq_anf$##7205759403792817859 :: "{v : (VMonad.VMonad a) | v == iMonad iMonadPlus}"
360:19-360:29::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
360:31-360:58::lq_anf$##7205759403792817861 :: "a ()"
360:38-360:48::iMonadPlus :: "{v : (VMonadPlus.VMonadPlus a) | v == iMonadPlus}"
360:49-360:57::lq_anf$##7205759403792817860 :: "{v : GHC.Types.Bool | v == vnot b\n                      && v == (if b then false else true)}"
360:55-360:56::b :: "{v : GHC.Types.Bool | v == b}"
360:59-360:60::y :: "{v : a b | v == y}"
373:1-373:22::guard_disjoint_branch :: "forall a b .\nx1:(VMonadPlus.VMonadPlus b) -> x2:GHC.Types.Bool -> x3:b b -> x4:b b -> {VV : () | vaddMP x1 (guard_disjoint x1 x2 x3 x4) (vbranch x2 x3 x4) == vbranch x2 x3 x4}"