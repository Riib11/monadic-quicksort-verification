{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}

{-@ LIQUID "--compile-spec" @-}

module Sort.ArrayProto where

import Data.Refined.Bool
import Data.Refined.List
import Data.Refined.Natural
import Data.Refined.Tuple
import Data.Refined.Unit
import Data.Text (Text, unpack)
import Function
import Language.Haskell.Liquid.Equational
import Language.Haskell.TH.Ppr (pprint)
import Language.Haskell.TH.Syntax
import NeatInterpolation (text)
import Placeholder.M
import Relation.Equality.Prop
import Relation.Equality.Prop.EDSL
import Relation.Equality.Prop.Reasoning
import Sort.Array
import Sort.List
import Prelude hiding (Monad, all, foldl, length, pure, read, readList, seq, (*), (+), (++), (>>), (>>=))

-- uses: [ref 9] and [ref 12] (recursively) and divide_and_conquer
-- desc: For this to work, we introduced two `perm` to permute both partitions
-- generated by partition. We can do so because `perm >=> perm = perm` and thus
-- `perm >=> slowsort = slowsort`. The term `perm zs` was combined with
-- `partition p`, yielding `partl' p`, while `perm ys` will be needed later. We
-- also needed [ref 9] to split `writeList i (ys' ++ [x] ++ zs')` into two
-- parts. Assuming that [ref 12] has been met for lists shorter than `xs`, two
-- subexpressions are folded back to `iqsort`.
{-@
iqsort_spec_lemma1 ::
  Equality (M ()) =>
  p:Int -> i:Natural -> xs:List Int ->
  EqualProp (M ())
    {iqsort_spec_lemma1_aux p i xs}
    {iqsort_spec_aux2 i (Cons p xs)}
@-}
iqsort_spec_lemma1 :: Equality (M ()) => Int -> Natural -> List Int -> EqualityProp (M ())
iqsort_spec_lemma1 p i xs =
  -- !ADMITTED
  [eqpropchain|
      iqsort_spec_lemma1_aux p i xs
    %==
      iqsort_spec_aux2 i (Cons p xs)
  |]

-- [ref 13]
-- uses: iqsort_spec_lemma1 [ref 10], ipartl_spec_lemma3 [ref 11]
-- desc: Now that we have introduced `partl'`, the next goal is to embed
-- `ipartl`. The status of the array before the two calls to `iqsort` is given
-- by `writeList i (ys' ++ [p] ++ zs)`. That is, `ys' ++ [p] ++ zs` is stored in
-- the array from index `i`, where `ys'` is a permutation of `ys`. The
-- postcondition of `ipartl`, according to the specification [ref 10], ends up
-- with `ys` and `zs` stored consecutively. To connect the two conditions, we
-- use a lemma that is dual to [ref 11]:
{-@
iqsort_spec_lemma2 ::
  Equality (M Unit) =>
  p:Int -> i:Natural -> ys:List Int ->
  RefinesPlus (Unit)
    {seq (writeList i (append (Cons p Nil) ys)) (swap i (add i (length ys)))}
    {iqsort_spec_lemma2_aux1 p i ys}
@-}
iqsort_spec_lemma2 :: Equality (M Unit) => Int -> Natural -> List Int -> EqualityProp (M Unit)
iqsort_spec_lemma2 p i ys =
  -- !ADMITTED
  [eqpropchain|
      seq (writeList i (append (Cons p Nil) ys)) (swap i (add i (length ys)))
    %== 
      iqsort_spec_lemma2_aux1 p i ys
  |]

-- uses: iqsort_spec_lemma1, iqsort_spec_lemma2 [ref 13]
-- desc. This is what the typical quicksort algorithm does: swapping the pivot
-- with the last element of `ys`, and [ref 13] says that it is valid because
-- that is one of the many permutations of `ys`. With [ref 13] and [ref 10], the
-- specification can be refined to:
{-@
iqsort_spec_lemma3 ::
  Equality (M ()) =>
  p:Int -> i:Natural -> xs:List Int ->
  RefinesPlus (Unit)
    {iqsort_spec_lemma3_aux p i xs}
    {iqsort_spec_lemma1_aux p i xs}
@-}
iqsort_spec_lemma3 :: Equality (M ()) => Int -> Natural -> List Int -> EqualityProp (M ())
iqsort_spec_lemma3 p i xs =
  -- !ADMITTED
  [eqpropchain|
      iqsort_spec_aux2 i (Cons p xs)
    %== --
      slowsort xs >>=
        writeList i
    %== --
      partl' p (Nil, Nil, xs) >>= \(ys, zs) ->
        permute ys >>= \ys' ->
          writeList i (ys' ++ Cons p Nil ++ zs) >>
            iqsort i (length ys) >>
              iqsort (S (i + length ys)) (length zs)
    %== --
      partl' p (Nil, Nil, xs) >>= \(ys, zs) ->
        permute ys >>=
          iqsort_spec_lemma1_aux_aux_aux p i ys zs
    %== --
      partl' p (Nil, Nil, xs) >>=
        iqsort_spec_lemma1_aux_aux p i
    %== --
      iqsort_spec_lemma1_aux p i xs
  |]

-- connects `iqsort_spec_lemma3` to `iqsort_spec` (`Cons` case)
{-@
iqsort_spec_lemma4 ::
  Equality (M ()) =>
  p:Int -> i:Natural -> xs:List Int ->
  RefinesPlus (Unit)
    {iqsort_spec_aux1 i (Cons p xs)}
    {iqsort_spec_lemma3_aux p i xs}
@-}
iqsort_spec_lemma4 :: Equality (M ()) => Int -> Natural -> List Int -> EqualityProp (M ())
iqsort_spec_lemma4 p i xs =
  -- !ADMITTED
  [eqpropchain|
      iqsort_spec_aux1 i (Cons p xs)
    %==
      iqsort_spec_lemma3_aux p i xs
  |]
