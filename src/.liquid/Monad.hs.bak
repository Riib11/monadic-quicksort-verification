{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE QuasiQuotes #-}
{-@ LIQUID "--typeclass" @-}
{-@ LIQUID "--reflection" @-}
{-@ LIQUID "--ple" @-}


module Monad where


import           Prelude                 hiding ( Monad(..)
                                                , (>>=)
                                                , (>>)
                                                , seq
                                                )
import           Liquid.ProofCombinators
import           Data.Function


{-@ infixr 1 >>= @-}
{-@ infixr 1 >> @-}
{-@ infixr 1 >=> @-}
{-@ infixr 1 <+> @-}
{-@ infixr 1 $+$ @-}


-- Monad
class Monad m where

  -- interface

  {-@ vlift :: forall a . a -> m a @-}
  -- [lq| vlift :: forall a . a -> m a |]
  vlift     :: forall a . a -> m a

  {-@ vbind :: forall a b . m a -> (a -> m b) -> m b @-}
  vbind     :: forall a b . m a -> (a -> m b) -> m b

  {-@ (>>=) :: forall a b . m a -> (a -> m b) -> m b @-}
  (>>=)     :: forall a b . m a -> (a -> m b) -> m b
  (>>=) = vbind

  {-@ seq :: forall a b . m a -> m b -> m b @-}
  seq     :: forall a b . m a -> m b -> m b

  {-@ (>>) :: forall a b . m a -> m b -> m b @-}
  (>>)     :: forall a b . m a -> m b -> m b
  (>>) = seq

  {-@ kleisli :: forall a b c . (a -> m b) -> (b -> m c) -> (a -> m c) @-}
  kleisli     :: forall a b c . (a -> m b) -> (b -> m c) -> (a -> m c)
  kleisli f g = \x -> vbind (f x) g

  {-@ (>=>) :: forall a b c . (a -> m b) -> (b -> m c) -> (a -> m c) @-}
  (>=>)     :: forall a b c . (a -> m b) -> (b -> m c) -> (a -> m c)
  (>=>) = kleisli

  -- properties

  {-@ vbind_identity_right :: forall a . m:m a ->
        {m >>= vlift = m} @-}
  vbind_identity_right :: m a -> Proof

  {-@ vlift_vbind :: forall a b . f:(a -> m b) -> a:a ->
        {vlift a >>= f = f a} @-}
  vlift_vbind :: (a -> m b) -> a -> Proof

  {-@ vbind_distribute_left :: forall a b c . m:m a -> f:(a -> m b) -> g:(b -> m c) ->
        {(m >>= f) >>= g = m >>= (f >=> g)} @-}
  vbind_distribute_left    :: forall a b c .  m a -> (a -> m b) -> (b -> m c) -> Proof

  -- utilities

  vlift2 :: (a -> b -> c) -> m a -> m b -> m c
  vlift2 f ma mb = ma >>= \x -> mb >>= \y -> vlift (f x y)

  -- minimal

  {-# MINIMAL vlift, vbind, vbind_identity_right, vlift_vbind, vbind_distribute_left #-}


-- MonadPlus
class Monad m => MonadPlus m where

  -- interface

  {-@ mzero :: forall a . m a @-}
  mzero     :: forall a . m a

  {-@ mplus :: forall a . m a -> m a -> m a @-}
  mplus     :: forall a . m a -> m a -> m a

  {-@ (<+>) :: forall a . m a -> m a -> m a @-}
  (<+>)     :: forall a . m a -> m a -> m a
  (<+>) = mplus

  {-@ mplus_ap :: forall a b . (a -> m b) -> (a -> m b) -> (a -> m b) @-}
  mplus_ap     :: forall a b . (a -> m b) -> (a -> m b) -> (a -> m b)
  mplus_ap f g x = f x <+> g x

  {-@ ($+$) :: forall a b . (a -> m b) -> (a -> m b) -> (a -> m b) @-}
  ($+$)     :: forall a b . (a -> m b) -> (a -> m b) -> (a -> m b)
  ($+$) = mplus_ap

  -- properties

  {-@ vbind_identity_left :: forall a b . f:(a -> m b) ->
        {mzero >>= f = mzero} @-}
  vbind_identity_left     :: forall a b . (a -> m b) -> Proof

  {-@ seq_identity_right :: forall a . m:m a ->
        {m >> mzero = mzero} @-}
  seq_identity_right     :: forall a . m a -> Proof

  {-@ mplus_distribute_left :: forall a b . m1:m a -> m2:m a -> f:(a -> m b) ->
        {(m1 <+> m2) >>= f = (m1 >>= f) <+> (m2 >>= f)} @-}
  mplus_distribute_left     :: forall a b . m a -> m a -> (a -> m b) -> Proof

  {-@ mplus_distribute_right :: forall a b . m: m a -> f:(a -> m b) -> g:(a -> m b) ->
        {m >>= (f $+$ g) = (m >>= f) <+> (m >>= g)} @-}
  mplus_distribute_right     :: forall a b . m a -> (a -> m b) -> (a -> m b) -> Proof

  -- utilities

  guard :: Bool -> m ()
  guard b = if b then vlift () else mzero

  -- minimal

  {-# MINIMAL mzero, mplus, vbind_identity_left, seq_identity_right, mplus_distribute_left, mplus_distribute_right #-}
