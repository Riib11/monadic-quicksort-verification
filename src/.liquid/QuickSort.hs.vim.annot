1:1-1:1::QuickSort.$trModule :: "GHC.Types.Module"
20:1-20:10::QuickSort.quicksort :: "forall a .\n(IsOrdered.IsOrdered a) -> (VList.VList a) -> (VList.VList a)"
20:11-20:15::iOrd :: "(IsOrdered.IsOrdered a)"
20:22-20:25::_ :: "{VV : forall a .\n      {v : (VList.VList a) | vlength v == Zero\n                             && v == Nil} | VV == Nil}"
22:8-22:10::ys :: "(VList.VList a)"
22:18-22:33::lq_anf$##7205759403792852839 :: "{v : ((VList.VList a), (VList.VList a)) | v == partition iOrd x xs\n                                          && v == partition_ x xs}"
22:29-22:30::x :: "{VV : a | VV == x}"
22:31-22:33::xs :: "{v : (VList.VList a) | v == xs}"
23:15-23:30::lq_anf$##7205759403792852841 :: "{v : (VList.VList a) | v == quicksort_ ys}"
23:27-23:29::ys :: "{v : (VList.VList a) | v == ys}"
23:31-23:71::lq_anf$##7205759403792852844 :: "(VList.VList a)"
23:40-23:54::lq_anf$##7205759403792852842 :: "{v : (VList.VList a) | v == vsingleton x\n                       && v == Cons x Nil}"
23:52-23:53::x :: "{VV : a | VV == x}"
23:55-23:70::lq_anf$##7205759403792852843 :: "{v : (VList.VList a) | v == quicksort_ ys}"
23:67-23:69::ys :: "{v : (VList.VList a) | v == ys}"
25:3-25:13::partition_ :: "x1:a -> x2:(VList.VList a) -> {v : ((VList.VList a), (VList.VList a)) | v == partition iOrd x1 x2}"
25:16-25:30::QuickSort.partition :: "forall a .\nx1:(IsOrdered.IsOrdered a) -> x2:a -> x3:(VList.VList a) -> {VV : ((VList.VList a), (VList.VList a)) | VV == partition x1 x2 x3}"
25:26-25:30::iOrd :: "{v : (IsOrdered.IsOrdered a) | v == iOrd}"
26:3-26:13::quicksort_ :: "(VList.VList a) -> (VList.VList a)"
26:16-26:30::QuickSort.quicksort :: "forall a .\n(IsOrdered.IsOrdered a) -> (VList.VList a) -> (VList.VList a)"
26:26-26:30::iOrd :: "{v : (IsOrdered.IsOrdered a) | v == iOrd}"
43:1-43:24::QuickSort.partition_specification :: "forall a b .\nx1:(IsMonadPlus.IsMonadPlus a) -> x2:(IsOrdered.IsOrdered b) -> x3:b -> x4:(VList.VList b) -> {VV : a ((VList.VList b), (VList.VList b)) | VV == partition_specification x1 x2 x3 x4\n                                                                                                                                           && VV == vbind (isMonad x1) (split x1 x4) (mguardBy x1 (isSortedBetween x2 x3))}"
43:25-43:36::isMonadPlus :: "(IsMonadPlus.IsMonadPlus a)"
43:37-43:41::iOrd :: "(IsOrdered.IsOrdered a)"
43:42-43:43::x :: "a"
43:44-43:46::xs :: "(VList.VList a)"
44:3-44:14::lq_anf$##7205759403792852817 :: "{v : a ((VList.VList b), (VList.VList b)) | v == split isMonadPlus xs\n                                            && v == split_ xs}"
44:11-44:13::xs :: "{v : (VList.VList a) | v == xs}"
45:3-45:35::lq_anf$##7205759403792852819 :: "((VList.VList a), (VList.VList a)) -> b ((VList.VList a), (VList.VList a))"
45:14-45:34::lq_anf$##7205759403792852818 :: "x1:((VList.VList a), (VList.VList a)) -> {v : GHC.Types.Bool | v == isSortedBetween iOrd x x1\n                                                               && v == (vall lam y##acSe : a##xo . leq iOrd y##acSe x (lqdc##$select x1)\n                                                                        && vall lam z##acSf : a##xo . leq iOrd x z##acSf (lqdc##$select x1))}"
45:32-45:33::x :: "{VV : a | VV == x}"
47:3-47:9::vbind_ :: "forall a b . c a -> (a -> c b) -> c b"
47:23-47:37::_ :: "{VV : forall a b . c a -> (a -> c b) -> c b | VV == vbind isMonad_}"
47:29-47:37::isMonad_ :: "{v : (IsMonad.IsMonad a) | v == isMonad isMonadPlus\n                           && v == isMonad_}"
48:3-48:11::isMonad_ :: "{v : (IsMonad.IsMonad a) | v == isMonad isMonadPlus}"
48:25-48:44::_ :: "{v : (IsMonad.IsMonad a) | v == isMonad isMonadPlus}"
48:33-48:44::isMonadPlus :: "{v : (IsMonadPlus.IsMonadPlus a) | v == isMonadPlus}"
49:3-49:19::isSortedBetween_ :: "x1:a -> x2:((VList.VList a), (VList.VList a)) -> {v : GHC.Types.Bool | v == isSortedBetween iOrd x1 x2\n                                                                       && v == (vall lam y##acSe : a##xo . leq iOrd y##acSe x1 (lqdc##$select x2)\n                                                                                && vall lam z##acSf : a##xo . leq iOrd x1 z##acSf (lqdc##$select x2))}"
49:22-49:42::_ :: "x1:a -> x2:((VList.VList a), (VList.VList a)) -> {v : GHC.Types.Bool | v == isSortedBetween iOrd x1 x2\n                                                                       && v == (vall lam y##acSe : a##xo . leq iOrd y##acSe x1 (lqdc##$select x2)\n                                                                                && vall lam z##acSf : a##xo . leq iOrd x1 z##acSf (lqdc##$select x2))}"
49:38-49:42::iOrd :: "{v : (IsOrdered.IsOrdered a) | v == iOrd}"
50:3-50:9::split_ :: "forall a .\nx1:(VList.VList a) -> {v : b ((VList.VList a), (VList.VList a)) | v == split isMonadPlus x1}"
50:22-50:39::_ :: "x1:(VList.VList a) -> {v : b ((VList.VList a), (VList.VList a)) | v == split isMonadPlus x1}"
50:28-50:39::isMonadPlus :: "{v : (IsMonadPlus.IsMonadPlus a) | v == isMonadPlus}"
51:3-51:12::mguardBy_ :: "forall a .\nx1:(a -> GHC.Types.Bool) -> x3:a -> {v : b a | v == mguardBy isMonadPlus x1 x3\n                                               && v == vseq (isMonad isMonadPlus) (mguard isMonadPlus (x1 x3)) (vlift (isMonad isMonadPlus) x3)}"
51:22-51:42::_ :: "x1:(a -> GHC.Types.Bool) -> x3:a -> {v : b a | v == mguardBy isMonadPlus x1 x3\n                                               && v == vseq (isMonad isMonadPlus) (mguard isMonadPlus (x1 x3)) (vlift (isMonad isMonadPlus) x3)}"
51:31-51:42::isMonadPlus :: "{v : (IsMonadPlus.IsMonadPlus a) | v == isMonadPlus}"
62:1-62:10::QuickSort.partition :: "forall a .\nx1:(IsOrdered.IsOrdered a) -> x2:a -> x3:(VList.VList a) -> {VV : ((VList.VList a), (VList.VList a)) | VV == partition x1 x2 x3}"
62:11-62:15::iOrd :: "(IsOrdered.IsOrdered a)"
62:16-62:18::x' :: "a"
62:25-62:35::lq_anf$##7205759403792852822 :: "{v : (VList.VList a) | vlength v == Zero\n                       && v == Nil}"
62:26-62:29::_ :: "{VV : forall a .\n      {v : (VList.VList a) | vlength v == Zero\n                             && v == Nil} | VV == Nil}"
62:31-62:34::_ :: "{VV : forall a .\n      {v : (VList.VList a) | vlength v == Zero\n                             && v == Nil} | VV == Nil}"
64:8-64:10::ys :: "(VList.VList a)"
64:12-64:14::zs :: "(VList.VList a)"
64:18-64:37::QuickSort.partition :: "forall a .\nx1:(IsOrdered.IsOrdered a) -> x2:a -> x3:(VList.VList a) -> {VV : ((VList.VList a), (VList.VList a)) | VV == partition x1 x2 x3}"
64:28-64:32::iOrd :: "{v : (IsOrdered.IsOrdered a) | v == iOrd}"
64:33-64:34::x :: "{VV : a | VV == x}"
64:35-64:37::xs :: "{v : (VList.VList a) | v == xs}"
65:10-65:19::lq_anf$##7205759403792852823 :: "{v : GHC.Types.Bool | v == leq_ x x'}"
65:15-65:16::x :: "{VV : a | VV == x}"
65:17-65:19::x' :: "{VV : a | VV == x'}"
65:25-65:40::GHC.Tuple.(,) :: "{VV : forall a b <p2 :: a b -> Bool>.\n      x1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | x_Tuple22 v == x2\n                                                                                           && x_Tuple21 v == x1\n                                                                                           && lqdc##$select v == x2\n                                                                                           && lqdc##$select v == x1\n                                                                                           && snd v == x2\n                                                                                           && fst v == x1\n                                                                                           && v == (,) x1 x2} | VV == (,)}"
65:26-65:35::lq_anf$##7205759403792852826 :: "{v : (VList.VList a) | tl v == ys\n                       && hd v == x\n                       && vlength v == Suc (vlength ys)\n                       && v == Cons x ys}"
65:31-65:32::x :: "{VV : a | VV == x}"
65:33-65:35::ys :: "{v : (VList.VList a) | v == ys}"
65:37-65:39::zs :: "{v : (VList.VList a) | v == zs}"
65:46-65:61::GHC.Tuple.(,) :: "{VV : forall a b <p2 :: a b -> Bool>.\n      x1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | x_Tuple22 v == x2\n                                                                                           && x_Tuple21 v == x1\n                                                                                           && lqdc##$select v == x2\n                                                                                           && lqdc##$select v == x1\n                                                                                           && snd v == x2\n                                                                                           && fst v == x1\n                                                                                           && v == (,) x1 x2} | VV == (,)}"
65:47-65:49::ys :: "{v : (VList.VList a) | v == ys}"
65:51-65:60::lq_anf$##7205759403792852825 :: "{v : (VList.VList a) | tl v == zs\n                       && hd v == x\n                       && vlength v == Suc (vlength zs)\n                       && v == Cons x zs}"
65:56-65:57::x :: "{VV : a | VV == x}"
65:58-65:60::zs :: "{v : (VList.VList a) | v == zs}"
66:9-66:13::leq_ :: "a -> a -> GHC.Types.Bool"
66:16-66:24::_ :: "a -> a -> GHC.Types.Bool"
66:20-66:24::iOrd :: "{v : (IsOrdered.IsOrdered a) | v == iOrd}"
82:1-82:18::QuickSort.partition_correct :: "forall a b .\nx1:(IsMonadPlus.IsMonadPlus b) -> x2:(IsOrdered.IsOrdered b) -> x3:b -> x4:(VList.VList b) -> {VV : () | vmadd x1 (vlift (isMonad x1) (partition x2 x3 x4)) (partition_specification x1 x2 x3 x4) == partition_specification x1 x2 x3 x4}"
82:19-82:30::isMonadPlus :: "(IsMonadPlus.IsMonadPlus a)"
82:31-82:35::iOrd :: "(IsOrdered.IsOrdered a)"
82:36-82:37::x :: "a"
82:38-82:40::xs :: "(VList.VList a)"
94:1-94:14::QuickSort.slowsort_step :: "forall a b .\nx1:(IsMonadPlus.IsMonadPlus a) -> x2:(IsOrdered.IsOrdered b) -> x3:b -> x4:(VList.VList b) -> {VV : a (VList.VList b) | VV == slowsort_step x1 x2 x3 x4\n                                                                                                                        && VV == vbind (isMonad x1) (vlift (isMonad x1) (partition x2 x3 x4)) lam ds_dfoG : (Tuple (VList.VList a##afkY) (VList.VList a##afkY)) . vbind (isMonad x1) (slowsort x1 x2 (lqdc##$select ds_dfoG)) lam ys'##afir : (VList.VList a##afkY) . vbind (isMonad x1) (slowsort x1 x2 (lqdc##$select ds_dfoG)) lam zs'##afis : (VList.VList a##afkY) . vlift (isMonad x1) (vappend ys'##afir (vappend (vsingleton x3) zs'##afis))}"
94:15-94:26::isMonadPlus :: "(IsMonadPlus.IsMonadPlus a)"
94:27-94:31::iOrd :: "(IsOrdered.IsOrdered a)"
94:32-94:33::x :: "a"
94:34-94:36::xs :: "(VList.VList a)"
95:3-95:29::lq_anf$##7205759403792852828 :: "a ((VList.VList b), (VList.VList b))"
95:11-95:28::lq_anf$##7205759403792852827 :: "{v : ((VList.VList a), (VList.VList a)) | v == partition iOrd x xs\n                                          && v == partition_ x xs}"
95:23-95:24::x :: "{VV : a | VV == x}"
95:25-95:27::xs :: "{v : (VList.VList a) | v == xs}"
97:5-97:19::lq_anf$##7205759403792852830 :: "{v : a (VList.VList b) | v == slowsort isMonadPlus iOrd ys\n                         && v == kleisli (isMonad isMonadPlus) (permute isMonadPlus) (mguardBy isMonadPlus (isSorted iOrd)) ys\n                         && v == slowsort_ ys}"
97:16-97:18::ys :: "{v : (VList.VList a) | v == ys}"
98:7-98:10::ys' :: "(VList.VList a)"
99:7-99:21::lq_anf$##7205759403792852831 :: "{v : a (VList.VList b) | v == slowsort isMonadPlus iOrd zs\n                         && v == kleisli (isMonad isMonadPlus) (permute isMonadPlus) (mguardBy isMonadPlus (isSorted iOrd)) zs\n                         && v == slowsort_ zs}"
99:18-99:20::zs :: "{v : (VList.VList a) | v == zs}"
100:7-100:66::vlift_ :: "{VV : forall a . a -> b a | VV == vlift isMonad_\n                            && VV == vlift_}"
100:9-100:12::zs' :: "(VList.VList a)"
100:23-100:65::lq_anf$##7205759403792852834 :: "(VList.VList a)"
100:32-100:35::ys' :: "{v : (VList.VList a) | v == ys'}"
100:36-100:64::lq_anf$##7205759403792852833 :: "(VList.VList a)"
100:45-100:59::lq_anf$##7205759403792852832 :: "{v : (VList.VList a) | v == vsingleton x\n                       && v == Cons x Nil}"
100:57-100:58::x :: "{VV : a | VV == x}"
100:60-100:63::zs' :: "{v : (VList.VList a) | v == zs'}"
104:3-104:12::slowsort_ :: "x1:(VList.VList a) -> {v : b (VList.VList a) | v == slowsort isMonadPlus iOrd x1\n                                               && v == kleisli (isMonad isMonadPlus) (permute isMonadPlus) (mguardBy isMonadPlus (isSorted iOrd)) x1}"
104:16-104:41::_ :: "x1:(VList.VList a) -> {v : b (VList.VList a) | v == slowsort isMonadPlus iOrd x1\n                                               && v == kleisli (isMonad isMonadPlus) (permute isMonadPlus) (mguardBy isMonadPlus (isSorted iOrd)) x1}"
104:25-104:36::isMonadPlus :: "{v : (IsMonadPlus.IsMonadPlus a) | v == isMonadPlus}"
104:37-104:41::iOrd :: "{v : (IsOrdered.IsOrdered a) | v == iOrd}"
105:3-105:13::partition_ :: "x1:a -> x2:(VList.VList a) -> {v : ((VList.VList a), (VList.VList a)) | v == partition iOrd x1 x2}"
105:16-105:30::QuickSort.partition :: "forall a .\nx1:(IsOrdered.IsOrdered a) -> x2:a -> x3:(VList.VList a) -> {VV : ((VList.VList a), (VList.VList a)) | VV == partition x1 x2 x3}"
105:26-105:30::iOrd :: "{v : (IsOrdered.IsOrdered a) | v == iOrd}"
106:3-106:9::vlift_ :: "forall a . a -> b a"
106:17-106:31::_ :: "{VV : forall a . a -> b a | VV == vlift isMonad_}"
106:23-106:31::isMonad_ :: "{v : (IsMonad.IsMonad a) | v == isMonad isMonadPlus\n                           && v == isMonad_}"
107:3-107:9::vbind_ :: "forall a b . c a -> (a -> c b) -> c b"
107:17-107:31::_ :: "{VV : forall a b . c a -> (a -> c b) -> c b | VV == vbind isMonad_}"
107:23-107:31::isMonad_ :: "{v : (IsMonad.IsMonad a) | v == isMonad isMonadPlus\n                           && v == isMonad_}"
108:3-108:11::isMonad_ :: "{v : (IsMonad.IsMonad a) | v == isMonad isMonadPlus}"
108:19-108:38::_ :: "{v : (IsMonad.IsMonad a) | v == isMonad isMonadPlus}"
108:27-108:38::isMonadPlus :: "{v : (IsMonadPlus.IsMonadPlus a) | v == isMonadPlus}"
123:1-123:19::QuickSort.divide_and_conquer :: "forall a b .\nx1:(IsMonadPlus.IsMonadPlus b) -> x2:(IsOrdered.IsOrdered b) -> x3:b -> x4:(VList.VList b) -> {VV : () | vmadd x1 (slowsort_step x1 x2 x3 x4) (slowsort x1 x2 (Cons x3 x4)) == slowsort x1 x2 (Cons x3 x4)}"
123:20-123:27::isMonadPlus :: "(IsMonadPlus.IsMonadPlus a)"
123:28-123:32::iOrd :: "(IsOrdered.IsOrdered a)"
123:33-123:34::x :: "a"
123:35-123:37::xs :: "(VList.VList a)"