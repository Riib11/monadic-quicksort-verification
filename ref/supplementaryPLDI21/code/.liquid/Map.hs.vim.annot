1:1-1:1::Map.$trModule :: "GHC.Types.Module"
20:1-20:7::Map.client :: "x1:[{v : GHC.Integer.Type.Integer | 0 <= v}] -> {VV : (PropositionalEquality.EqT [GHC.Integer.Type.Integer]) | eqT (map add1Int x1) (map add1Nat x1)}"
20:16-20:23::RefinedDomains.add1Int :: "x1:GHC.Integer.Type.Integer -> {v : GHC.Integer.Type.Integer | v == add1Int x1\n                                                               && v == x1 + 1}"
20:24-20:31::RefinedDomains.add1Nat :: "x1:GHC.Integer.Type.Integer -> {v : GHC.Integer.Type.Integer | v == add1Nat x1\n                                                               && v == (if x1 >= 0 then x1 + 1 else 0)}"
20:32-20:34::RefinedDomains.pf :: "{v : (PropositionalEquality.EqT {v : GHC.Integer.Type.Integer | 0 <= v} -> GHC.Integer.Type.Integer) | eqT add1Int add1Nat\n                                                                                                       && v == pf}"
24:1-24:9::Map.client'' :: "{VV : (PropositionalEquality.EqT [{v : GHC.Integer.Type.Integer | 0 <= v}] -> [GHC.Integer.Type.Integer]) | eqT (map add1Int) (map add1Nat)}"
24:20-24:27::RefinedDomains.add1Int :: "x1:GHC.Integer.Type.Integer -> {v : GHC.Integer.Type.Integer | v == add1Int x1\n                                                               && v == x1 + 1}"
24:28-24:35::RefinedDomains.add1Nat :: "x1:GHC.Integer.Type.Integer -> {v : GHC.Integer.Type.Integer | v == add1Nat x1\n                                                               && v == (if x1 >= 0 then x1 + 1 else 0)}"
24:36-24:38::RefinedDomains.pf :: "{v : (PropositionalEquality.EqT {v : GHC.Integer.Type.Integer | 0 <= v} -> GHC.Integer.Type.Integer) | eqT add1Int add1Nat\n                                                                                                       && v == pf}"
31:1-31:6::Map.mapEq :: "forall a b .\nx1:(a -> b) -> x3:(a -> b) -> {VV : (PropositionalEquality.EqT (a -> b)) | eqT x1 x3} -> x7:[a] -> {VV : (PropositionalEquality.EqT [b]) | eqT (map x1 x7) (map x3 x7)}"
31:7-31:8::f :: "a -> b"
31:9-31:10::g :: "a -> b"
31:11-31:14::mpf :: "{VV : (PropositionalEquality.EqT a -> b) | eqT f g}"
31:15-31:17::xs :: "[a]"
32:3-32:29::lq_anf$##7205759403792844361 :: "{v : (PropositionalEquality.EqT [a]) | lqdc##$select v == mpf\n                                       && lqdc##$select v == g\n                                       && lqdc##$select v == f}"
32:9-32:10::f :: "a -> b"
32:11-32:12::g :: "a -> b"
32:13-32:16::mpf :: "{v : (PropositionalEquality.EqT a -> b) | eqT f g\n                                          && v == mpf}"
32:17-32:29::lq_anf$##7205759403792844360 :: "x1:(a -> b) -> {v : [b] | v == flipMap xs x1\n                          && v == map x1 xs}"
32:26-32:28::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
33:5-33:20::lq_anf$##7205759403792844362 :: "{v : () | map f xs == flipMap xs f\n          && v == mapFlipMap f xs}"
33:16-33:17::f :: "a -> b"
33:18-33:20::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
34:5-34:20::lq_anf$##7205759403792844364 :: "{v : () | map g xs == flipMap xs g\n          && v == mapFlipMap g xs}"
34:16-34:17::g :: "a -> b"
34:18-34:20::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
38:1-38:11::Map.mapFlipMap :: "forall a b .\nx1:(a -> b) -> x3:[a] -> {VV : () | map x1 x3 == flipMap x3 x1}"
38:12-38:14::_f :: "a -> b"
38:15-38:18::_xs :: "[a]"
44:1-44:7::Map.mapEq' :: "forall a b .\n(PEqProperties.Reflexivity<[]> [a], PEqProperties.Transitivity<[]> [a]) =>\nx3:(b -> a) -> x5:(b -> a) -> {VV : (PropositionalEquality.EqT (b -> a)) | eqT x3 x5} -> x9:[b] -> {VV : (PropositionalEquality.EqT [a]) | eqT (map x3 x9) (map x5 x9)}"
44:8-44:9::f :: "a -> b"
44:10-44:11::g :: "a -> b"
44:12-44:15::mpf :: "{VV : (PropositionalEquality.EqT a -> b) | eqT f g}"
44:16-44:18::xs :: "[a]"
45:9-45:19::lq_anf$##7205759403792844366 :: "{v : [a] | v == map f xs}"
45:14-45:15::f :: "a -> b"
45:16-45:18::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
46:9-46:23::lq_anf$##7205759403792844367 :: "{v : [a] | v == flipMap xs f\n           && v == map f xs}"
46:18-46:20::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
46:21-46:22::f :: "a -> b"
47:9-47:19::lq_anf$##7205759403792844368 :: "{v : [a] | v == map g xs}"
47:14-47:15::g :: "a -> b"
47:16-47:18::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
48:5-48:22::lq_anf$##7205759403792844370 :: "(PropositionalEquality.EqT [a])"
48:11-48:21::lq_anf$##7205759403792844369 :: "{v : [a] | v == map f xs}"
48:16-48:17::f :: "a -> b"
48:18-48:20::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
49:12-49:26::lq_anf$##7205759403792844371 :: "{v : [a] | v == flipMap xs f\n           && v == map f xs}"
49:21-49:23::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
49:24-49:25::f :: "a -> b"
50:12-50:26::lq_anf$##7205759403792844372 :: "{v : [a] | v == flipMap xs g\n           && v == map g xs}"
50:21-50:23::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
50:24-50:25::g :: "a -> b"
51:12-51:22::lq_anf$##7205759403792844373 :: "{v : [a] | v == map g xs}"
51:17-51:18::g :: "a -> b"
51:19-51:21::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
52:7-52:35::lq_anf$##7205759403792844375 :: "{v : (PropositionalEquality.EqT [a]) | lqdc##$select v == mpf\n                                       && lqdc##$select v == g\n                                       && lqdc##$select v == f}"
52:14-52:15::f :: "a -> b"
52:16-52:17::g :: "a -> b"
52:18-52:21::mpf :: "{v : (PropositionalEquality.EqT a -> b) | eqT f g\n                                          && v == mpf}"
52:22-52:34::lq_anf$##7205759403792844374 :: "x1:(a -> b) -> {v : [b] | v == flipMap xs x1\n                          && v == map x1 xs}"
52:31-52:33::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
53:7-53:28::lq_anf$##7205759403792844377 :: "(PropositionalEquality.EqT [a])"
53:13-53:27::lq_anf$##7205759403792844376 :: "{v : [a] | v == flipMap xs g\n           && v == map g xs}"
53:22-53:24::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
53:25-53:26::g :: "a -> b"
59:1-59:8::Map.mapEq'' :: "forall a b .\nx1:(a -> b) -> x3:(a -> b) -> {VV : (PropositionalEquality.EqT (a -> b)) | eqT x1 x3} -> {VV : (PropositionalEquality.EqT [a] -> [b]) | eqT (map x1) (map x3)}"
59:9-59:10::f :: "a -> b"
59:11-59:12::g :: "a -> b"
59:13-59:16::mpf :: "{VV : (PropositionalEquality.EqT a -> b) | eqT f g}"
59:25-59:26::f :: "a -> b"
59:27-59:28::g :: "a -> b"
59:29-59:32::mpf :: "{v : (PropositionalEquality.EqT a -> b) | eqT f g\n                                          && v == mpf}"
59:33-59:36::Map.map :: "forall a b . x1:(a -> b) -> x3:[a] -> {VV : [b] | VV == map x1 x3}"
69:1-69:8::Map.flipMap :: "forall a b .\nx1:[a] -> x2:(a -> b) -> {VV : [b] | VV == flipMap x1 x2\n                                     && VV == map x2 x1}"
69:9-69:11::xs :: "[a]"
69:12-69:13::f :: "a -> b"
69:20-69:21::f :: "a -> b"
69:22-69:24::xs :: "{v : [a] | len v >= 0\n           && v == xs}"
73:1-73:4::Map.map :: "forall a b . x1:(a -> b) -> x3:[a] -> {VV : [b] | VV == map x1 x3}"
73:5-73:7::_f :: "a -> b"
73:17-73:19::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | len v == 0\n                                                  && v == []} | VV == []}"
74:17-74:20::lq_anf$##7205759403792844358 :: "{VV : a | VV == _f x}"
74:19-74:20::x :: "{VV : a | VV == x}"
74:23-74:31::lq_anf$##7205759403792844359 :: "{v : [a] | v == map _f xs}"
74:27-74:28::_f :: "a -> b"
74:29-74:31::xs :: "{v : [a] | len v >= 0\n           && v == xs}"