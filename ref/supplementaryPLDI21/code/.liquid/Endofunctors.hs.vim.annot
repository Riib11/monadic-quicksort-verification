1:1-1:1::Endofunctors.$trModule :: "GHC.Types.Module"
20:1-20:7::Endofunctors.mempty :: "forall a .\nx1:a -> {VV : a | VV == mempty x1\n                  && VV == x1}"
20:8-20:9::a :: "a"
24:1-24:8::Endofunctors.mappend :: "forall a .\nx1:(a -> a) -> x3:(a -> a) -> x5:a -> {VV : a | VV == mappend x1 x3 x5\n                                                && VV == x1 (x3 x5)}"
24:9-24:10::f :: "a -> a"
24:11-24:12::g :: "a -> a"
24:13-24:14::a :: "a"
24:19-24:24::lq_anf$##7205759403792824435 :: "{VV : a | VV == g a}"
24:22-24:23::a :: "{VV : a | VV == a}"
34:1-34:20::Endofunctors.monoid_leftIdentity :: "forall a .\n(PEqProperties.Reflexivity<[]> a) =>\nx2:(a -> a) -> {VV : (PropositionalEquality.EqT a -> a) | eqT (mappend mempty x2) x2}"
34:21-34:22::x :: "a -> a"
35:3-35:29::lq_anf$##7205759403792824463 :: "x1:(a -> (PropositionalEquality.EqT a)) -> {v : (PropositionalEquality.EqT a -> a) | lqdc##$select v == x1\n                                                                                     && lqdc##$select v == x}"
35:9-35:27::lq_anf$##7205759403792824462 :: "a -> a"
35:18-35:24::_ :: "{VV : forall a .\n      x1:a -> {VV : a | VV == mempty x1\n                        && VV == x1} | VV == mempty}"
35:25-35:26::x :: "a -> a"
35:28-35:29::x :: "a -> a"
35:33-35:34::a :: "a"
36:5-36:30::lq_anf$##7205759403792824466 :: "(PropositionalEquality.EqT a)"
36:10-36:30::lq_anf$##7205759403792824465 :: "a"
36:19-36:25::_ :: "{VV : forall a .\n      x1:a -> {VV : a | VV == mempty x1\n                        && VV == x1} | VV == mempty}"
36:26-36:27::x :: "a -> a"
36:28-36:29::a :: "{VV : a | VV == a}"
37:15-37:33::lq_anf$##7205759403792824468 :: "a"
37:23-37:29::_ :: "{VV : forall a .\n      x1:a -> {VV : a | VV == mempty x1\n                        && VV == x1} | VV == mempty}"
37:30-37:31::x :: "a -> a"
37:32-37:33::a :: "{VV : a | VV == a}"
38:15-38:27::lq_anf$##7205759403792824470 :: "a"
38:22-38:27::lq_anf$##7205759403792824469 :: "{VV : a | VV == x a}"
38:25-38:26::a :: "{VV : a | VV == a}"
39:15-39:18::lq_anf$##7205759403792824472 :: "{VV : a | VV == x a}"
39:17-39:18::a :: "{VV : a | VV == a}"
40:15-40:18::Language.Haskell.Liquid.ProofCombinators.QED :: "{v : Language.Haskell.Liquid.ProofCombinators.QED | v == QED}"
44:1-44:21::Endofunctors.monoid_rightIdentity :: "forall a .\n(PEqProperties.Reflexivity<[]> a) =>\nx2:(a -> a) -> {VV : (PropositionalEquality.EqT a -> a) | eqT x2 (mappend x2 mempty)}"
44:22-44:23::x :: "a -> a"
45:5-45:31::lq_anf$##7205759403792824478 :: "x1:(a -> (PropositionalEquality.EqT a)) -> {v : (PropositionalEquality.EqT a -> a) | lqdc##$select v == x1\n                                                                                     && lqdc##$select v == x}"
45:11-45:12::x :: "a -> a"
45:13-45:31::lq_anf$##7205759403792824477 :: "a -> a"
45:22-45:23::x :: "a -> a"
45:24-45:30::_ :: "{VV : forall a .\n      x1:a -> {VV : a | VV == mempty x1\n                        && VV == x1} | VV == mempty}"
45:35-45:36::a :: "a"
46:7-46:17::lq_anf$##7205759403792824480 :: "(PropositionalEquality.EqT a)"
46:12-46:17::lq_anf$##7205759403792824479 :: "{VV : a | VV == x a}"
46:15-46:16::a :: "{VV : a | VV == a}"
47:17-47:20::lq_anf$##7205759403792824481 :: "{VV : a | VV == x a}"
47:19-47:20::a :: "{VV : a | VV == a}"
48:17-48:29::lq_anf$##7205759403792824483 :: "a"
48:19-48:29::lq_anf$##7205759403792824482 :: "{VV : a | VV == mempty a\n          && VV == a}"
48:27-48:28::a :: "{VV : a | VV == a}"
49:17-49:35::lq_anf$##7205759403792824486 :: "a"
49:25-49:26::x :: "a -> a"
49:27-49:33::_ :: "{VV : forall a .\n      x1:a -> {VV : a | VV == mempty x1\n                        && VV == x1} | VV == mempty}"
49:34-49:35::a :: "{VV : a | VV == a}"
50:17-50:20::Language.Haskell.Liquid.ProofCombinators.QED :: "{v : Language.Haskell.Liquid.ProofCombinators.QED | v == QED}"
56:1-56:21::Endofunctors.monoid_associativity :: "forall a .\n(PEqProperties.Reflexivity<[]> a) =>\nx2:(a -> a) -> x4:(a -> a) -> x6:(a -> a) -> {VV : (PropositionalEquality.EqT a -> a) | eqT (mappend (mappend x2 x4) x6) (mappend x2 (mappend x4 x6))}"
56:22-56:23::x :: "a -> a"
56:24-56:25::y :: "a -> a"
56:26-56:27::z :: "a -> a"
57:3-57:60::lq_anf$##7205759403792824440 :: "x1:(a -> (PropositionalEquality.EqT a)) -> {v : (PropositionalEquality.EqT a -> a) | lqdc##$select v == x1}"
57:9-57:34::lq_anf$##7205759403792824437 :: "a -> a"
57:18-57:31::lq_anf$##7205759403792824436 :: "x1:a -> {VV : a | VV == mappend x y x1\n                  && VV == x (y x1)}"
57:27-57:28::x :: "a -> a"
57:29-57:30::y :: "a -> a"
57:32-57:33::z :: "a -> a"
57:35-57:60::lq_anf$##7205759403792824439 :: "a -> a"
57:44-57:45::x :: "a -> a"
57:46-57:59::lq_anf$##7205759403792824438 :: "x1:a -> {VV : a | VV == mappend y z x1\n                  && VV == y (z x1)}"
57:55-57:56::y :: "a -> a"
57:57-57:58::z :: "a -> a"
57:64-57:65::a :: "a"
58:5-58:37::lq_anf$##7205759403792824443 :: "(PropositionalEquality.EqT a)"
58:10-58:37::lq_anf$##7205759403792824442 :: "a"
58:19-58:32::lq_anf$##7205759403792824441 :: "x1:a -> {VV : a | VV == mappend x y x1\n                  && VV == x (y x1)}"
58:28-58:29::x :: "a -> a"
58:30-58:31::y :: "a -> a"
58:33-58:34::z :: "a -> a"
58:35-58:36::a :: "{VV : a | VV == a}"
59:15-59:40::lq_anf$##7205759403792824445 :: "a"
59:23-59:36::lq_anf$##7205759403792824444 :: "x1:a -> {VV : a | VV == mappend x y x1\n                  && VV == x (y x1)}"
59:32-59:33::x :: "a -> a"
59:34-59:35::y :: "a -> a"
59:37-59:38::z :: "a -> a"
59:39-59:40::a :: "{VV : a | VV == a}"
60:15-60:34::lq_anf$##7205759403792824447 :: "a"
60:24-60:25::x :: "a -> a"
60:26-60:27::y :: "a -> a"
60:29-60:34::lq_anf$##7205759403792824446 :: "{VV : a | VV == z a}"
60:32-60:33::a :: "{VV : a | VV == a}"
61:15-61:26::lq_anf$##7205759403792824451 :: "a"
61:17-61:26::lq_anf$##7205759403792824450 :: "a"
61:20-61:25::lq_anf$##7205759403792824449 :: "{VV : a | VV == z a}"
61:23-61:24::a :: "{VV : a | VV == a}"
62:15-62:32::lq_anf$##7205759403792824454 :: "a"
62:17-62:32::lq_anf$##7205759403792824453 :: "{VV : a | VV == mappend y z a\n          && VV == y (z a)}"
62:26-62:27::y :: "a -> a"
62:28-62:29::z :: "a -> a"
62:30-62:31::a :: "{VV : a | VV == a}"
63:15-63:40::lq_anf$##7205759403792824457 :: "a"
63:23-63:24::x :: "a -> a"
63:25-63:38::lq_anf$##7205759403792824456 :: "x1:a -> {VV : a | VV == mappend y z x1\n                  && VV == y (z x1)}"
63:34-63:35::y :: "a -> a"
63:36-63:37::z :: "a -> a"
63:39-63:40::a :: "{VV : a | VV == a}"
64:15-64:18::Language.Haskell.Liquid.ProofCombinators.QED :: "{v : Language.Haskell.Liquid.ProofCombinators.QED | v == QED}"